export const weslBundle = {
  name: "wgsl_test",
  edition: "unstable_2025_1",
  modules: {
    "lib.wesl":
      "import package::TestResult::testResult;\n\nconst relTol: f32 = 1e-3;\nconst absTol: f32 = 1e-6;\n\nfn expect(condition: bool) {\n  if (!condition && testResult.failCount == 0u) {\n    testResult.passed = 0u;\n    testResult.failCount = 1u;\n  }\n}\n\nfn expectEq(actual: u32, expected: u32) {\n  testResult.actual = vec4f(f32(actual), 0.0, 0.0, 0.0);\n  testResult.expected = vec4f(f32(expected), 0.0, 0.0, 0.0);\n  if (actual != expected && testResult.failCount == 0u) {\n    testResult.passed = 0u;\n    testResult.failCount = 1u;\n  }\n}\n\nfn expectWithin(actual: f32, expected: f32, relTol: f32, absTol: f32) {\n  testResult.actual = vec4f(actual, 0.0, 0.0, 0.0);\n  testResult.expected = vec4f(expected, 0.0, 0.0, 0.0);\n  let diff = abs(actual - expected);\n  let tolerance = max(absTol, relTol * max(abs(actual), abs(expected)));\n  if (diff > tolerance && testResult.failCount == 0u) {\n    testResult.passed = 0u;\n    testResult.failCount = 1u;\n  }\n}\n\nfn expectNear(actual: f32, expected: f32) {\n  expectWithin(actual, expected, relTol, absTol);\n}\n\nfn expectWithinVec2(actual: vec2f, expected: vec2f, relTol: f32, absTol: f32) {\n  testResult.actual = vec4f(actual, 0.0, 0.0);\n  testResult.expected = vec4f(expected, 0.0, 0.0);\n  let diff = abs(actual - expected);\n  let tolerance = max(vec2f(absTol), relTol * max(abs(actual), abs(expected)));\n  if (any(diff > tolerance) && testResult.failCount == 0u) {\n    testResult.passed = 0u;\n    testResult.failCount = 1u;\n  }\n}\n\nfn expectNearVec2(actual: vec2f, expected: vec2f) {\n  expectWithinVec2(actual, expected, relTol, absTol);\n}\n\nfn expectWithinVec3(actual: vec3f, expected: vec3f, relTol: f32, absTol: f32) {\n  testResult.actual = vec4f(actual, 0.0);\n  testResult.expected = vec4f(expected, 0.0);\n  let diff = abs(actual - expected);\n  let tolerance = max(vec3f(absTol), relTol * max(abs(actual), abs(expected)));\n  if (any(diff > tolerance) && testResult.failCount == 0u) {\n    testResult.passed = 0u;\n    testResult.failCount = 1u;\n  }\n}\n\nfn expectNearVec3(actual: vec3f, expected: vec3f) {\n  expectWithinVec3(actual, expected, relTol, absTol);\n}\n\nfn expectWithinVec4(actual: vec4f, expected: vec4f, relTol: f32, absTol: f32) {\n  testResult.actual = actual;\n  testResult.expected = expected;\n  let diff = abs(actual - expected);\n  let tolerance = max(vec4f(absTol), relTol * max(abs(actual), abs(expected)));\n  if (any(diff > tolerance) && testResult.failCount == 0u) {\n    testResult.passed = 0u;\n    testResult.failCount = 1u;\n  }\n}\n\nfn expectNearVec4(actual: vec4f, expected: vec4f) {\n  expectWithinVec4(actual, expected, relTol, absTol);\n}\n\n// ULP (Units in Last Place) comparison - measures how many representable floats apart\nfn ulpDiff(actual: f32, expected: f32) -> u32 {\n  let aBits = bitcast<i32>(actual);\n  let bBits = bitcast<i32>(expected);\n  return u32(abs(aBits - bBits));\n}\n\nfn expectUlp(actual: f32, expected: f32, maxUlp: u32) {\n  testResult.actual = vec4f(actual, 0.0, 0.0, 0.0);\n  testResult.expected = vec4f(expected, 0.0, 0.0, 0.0);\n  if (actual == expected) { return; }  // handles +0 == -0, exact match\n  let diff = ulpDiff(actual, expected);\n  if (diff > maxUlp && testResult.failCount == 0u) {\n    testResult.passed = 0u;\n    testResult.failCount = 1u;\n  }\n}\n\nfn expectUlpVec2(actual: vec2f, expected: vec2f, maxUlp: u32) {\n  testResult.actual = vec4f(actual, 0.0, 0.0);\n  testResult.expected = vec4f(expected, 0.0, 0.0);\n  if (all(actual == expected)) { return; }\n  let d0 = ulpDiff(actual.x, expected.x);\n  let d1 = ulpDiff(actual.y, expected.y);\n  if ((d0 > maxUlp || d1 > maxUlp) && testResult.failCount == 0u) {\n    testResult.passed = 0u;\n    testResult.failCount = 1u;\n  }\n}\n\nfn expectUlpVec3(actual: vec3f, expected: vec3f, maxUlp: u32) {\n  testResult.actual = vec4f(actual, 0.0);\n  testResult.expected = vec4f(expected, 0.0);\n  if (all(actual == expected)) { return; }\n  let d0 = ulpDiff(actual.x, expected.x);\n  let d1 = ulpDiff(actual.y, expected.y);\n  let d2 = ulpDiff(actual.z, expected.z);\n  if ((d0 > maxUlp || d1 > maxUlp || d2 > maxUlp) && testResult.failCount == 0u) {\n    testResult.passed = 0u;\n    testResult.failCount = 1u;\n  }\n}\n\nfn expectUlpVec4(actual: vec4f, expected: vec4f, maxUlp: u32) {\n  testResult.actual = actual;\n  testResult.expected = expected;\n  if (all(actual == expected)) { return; }\n  let d0 = ulpDiff(actual.x, expected.x);\n  let d1 = ulpDiff(actual.y, expected.y);\n  let d2 = ulpDiff(actual.z, expected.z);\n  let d3 = ulpDiff(actual.w, expected.w);\n  if ((d0 > maxUlp || d1 > maxUlp || d2 > maxUlp || d3 > maxUlp) && testResult.failCount == 0u) {\n    testResult.passed = 0u;\n    testResult.failCount = 1u;\n  }\n}\n",
    "TestResult.wesl":
      "struct TestResult {\n  passed: u32,\n  failCount: u32,\n  actual: vec4f,\n  expected: vec4f,\n}\n\n@group(0) @binding(0) var<storage, read_write> testResult: TestResult;\n\nfn initTestResult() {\n  testResult.passed = 1u;\n  testResult.failCount = 0u;\n}\n",
  },
};

export default weslBundle;
