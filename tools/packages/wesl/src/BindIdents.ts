import type { AbstractElem } from "./AbstractElems.ts";
import { assertThatDebug } from "./Assertions.ts";
import { failIdent } from "./ClickableError.ts";
import { findConditional, validateConditional } from "./Conditions.ts";
import { identToString } from "./debug/ScopeToString.ts";
import type { FlatImport } from "./FlattenTreeImport.ts";
import type { LinkRegistryParams, VirtualLibraryFn } from "./Linker.ts";
import { type LiveDecls, makeLiveDecls } from "./LiveDeclarations.ts";
import { type ManglerFn, minimalMangle } from "./Mangler.ts";
import { resolveSuper } from "./ModulePathUtil.ts";
import type { ModuleResolver } from "./ModuleResolver.ts";
import { flatImports, parseSrcModule, type WeslAST } from "./ParseWESL.ts";
import type {
  Conditions,
  DeclIdent,
  LexicalScope,
  RefIdent,
  Scope,
  SrcModule,
} from "./Scope.ts";
import { stdEnumerant, stdFn, stdType } from "./StandardTypes.ts";
import { last } from "./Util.ts";

/**
 * BindIdents pass: link reference identifiers to declarations.
 *
 * Goals:
 * - Link reference idents to declaration idents
 * - Collect used declarations (to emit in link)
 * - Create mangled names for globals to avoid conflicts
 *
 * Algorithm:
 * - Recursive depth-first walk of scope tree (not syntax tree)
 * - For each ref: search current scope, then up to parent scopes
 * - If no local match: check import statements for external matches
 * - For found global decls: mangle name to be unique, collect for emission
 *
 * LiveDecls: tracks visible declarations at the current position, with parent links.
 *
 * @if/@else: respects conditional compilation by tracking @else validity state,
 * mirroring the emission phase's filterValidElements but on scopes.
 */

/** Results returned from binding pass. */
export interface BindResults {
  /** Root level names (including mangled names from conflicts). */
  globalNames: Set<string>;

  /** Global declarations referenced (to emit in link). */
  decls: DeclIdent[];

  /** Additional global statements to emit (e.g., const_assert). */
  newStatements: EmittableElem[];

  /** Unbound module paths (only if accumulateUnbound is true). */
  unbound?: string[][];
}

/** An element that can be directly emitted into the linked result. */
export interface EmittableElem {
  srcModule: SrcModule;
  elem: AbstractElem;
}

/** Virtual package generated by code generation function. */
export interface VirtualLibrary {
  // LATER rename to VirtualPackage?
  /** Function to generate the module. */
  fn: VirtualLibraryFn;

  /** Parsed AST for the module (constructed lazily). */
  ast?: WeslAST;
}

/** Key is virtual module name. */
export type VirtualLibrarySet = Record<string, VirtualLibrary>;

export interface BindIdentsParams
  extends Pick<LinkRegistryParams, "resolver" | "conditions" | "mangler"> {
  rootAst: WeslAST;
  virtuals?: VirtualLibrarySet;

  /** If true, accumulate unbound identifiers into BindResults.unbound instead of throwing. */
  accumulateUnbound?: true;
}

/** Bind ref idents to declarations and mangle global declaration names. */
export function bindIdents(params: BindIdentsParams): BindResults {
  const { rootAst, resolver, virtuals, accumulateUnbound } = params;
  const { conditions = {}, mangler = minimalMangle } = params;

  const validRootDecls = findValidRootDecls(rootAst.rootScope, conditions);
  const { globalNames, knownDecls } = initRootDecls(validRootDecls);

  const bindContext = {
    resolver,
    conditions,
    knownDecls,
    virtuals,
    mangler,
    foundScopes: new Set<Scope>(),
    globalNames,
    globalStatements: new Map<AbstractElem, EmittableElem>(),
    unbound: accumulateUnbound ? [] : undefined,
  };

  const decls = new Map(validRootDecls.map(d => [d.originalName, d] as const));
  const liveDecls: LiveDecls = { decls, parent: null };

  // Process dependent scopes for all valid root decls (already filtered by conditions)
  const fromRootDecls = validRootDecls.flatMap(decl =>
    processDependentScope(decl, bindContext),
  );

  const fromRefs = bindIdentsRecursive(
    rootAst.rootScope,
    bindContext,
    liveDecls,
  );
  const newStatements = [...bindContext.globalStatements.values()];
  return {
    decls: [...fromRootDecls, ...fromRefs],
    globalNames,
    newStatements,
    unbound: bindContext.unbound,
  };
}

/** Initialize root declarations with mangled names and add to tracking sets. */
function initRootDecls(validRootDecls: DeclIdent[]) {
  for (const d of validRootDecls) d.mangledName = d.originalName;
  const knownDecls = new Set(validRootDecls);
  const globalNames = new Set(validRootDecls.map(d => d.originalName));
  return { globalNames, knownDecls };
}

/** Get conditional attribute from any scope item. */
function getCondAttr(
  item: DeclIdent | RefIdent | Scope,
): Scope["condAttribute"] {
  // Decls inside PartialScopes don't need their own conditional checked -
  // the PartialScope.condAttribute handles filtering at the scope level.
  if (item.kind === "decl" && item.containingScope.kind === "partial")
    return undefined;
  if (item.kind === "decl") return findConditional(item.declElem?.attributes);
  if (item.kind === "partial" || item.kind === "scope")
    return item.condAttribute;
  return undefined;
}

/** Iterate scope contents, yielding only conditionally valid items. */
function* validItems(scope: Scope, conditions: Conditions) {
  let elseValid = false;
  for (const item of scope.contents) {
    const cond = validateConditional(getCondAttr(item), elseValid, conditions);
    elseValid = cond.nextElseState;
    if (cond.valid) yield item;
  }
}

/** Find all conditionally valid declarations at the root level. */
export function findValidRootDecls(
  rootScope: Scope,
  conditions: Conditions,
): DeclIdent[] {
  const found: DeclIdent[] = [];
  for (const item of validItems(rootScope, conditions)) {
    if (item.kind === "decl") found.push(item);
    else if (item.kind === "partial") collectDecls(item, found);
  }
  return found;
}

/** Find a public declaration with the given original name. */
export function publicDecl(
  scope: Scope,
  name: string,
  conditions: Conditions,
): DeclIdent | undefined {
  const validDecls = getValidRootDecls(scope, conditions);
  return validDecls.find(d => d.originalName === name);
}

/** @return true if this decl is at the root scope level of a module. */
export function isGlobal(declIdent: DeclIdent): boolean {
  // V2 parser sets isGlobal explicitly; V1 infers from declElem.kind
  if (declIdent.isGlobal !== undefined) return declIdent.isGlobal;
  const { declElem } = declIdent;
  if (!declElem) return false;
  const globalKinds = ["alias", "const", "override", "fn", "struct", "gvar"];
  return globalKinds.includes(declElem.kind);
}

/** State used during the recursive scope tree walk to bind references to declarations. */
interface BindContext {
  resolver: ModuleResolver;

  conditions: Conditions;

  /** Decl idents discovered so far (to avoid re-traversing). */
  knownDecls: Set<DeclIdent>;

  /** Scopes already processed (avoid duplicate work). */
  foundScopes: Set<Scope>;

  /** Root level names used so far (enables manglers to pick unique names). */
  globalNames: Set<string>;

  /** Additional global statements to emit (indexed by elem for uniqueness). */
  globalStatements: Map<AbstractElem, EmittableElem>;

  /** Construct unique identifier names for global declarations. */
  mangler: ManglerFn;

  virtuals?: VirtualLibrarySet;

  /** Unbound identifiers if accumulateUnbound is true. */
  unbound?: string[][];

  /** Don't follow references from declarations (for library dependency detection). */
  dontFollowDecls?: boolean;
}

/**
 * Recursively bind references to declarations in this scope and child scopes.
 * Tracks @else state to ensure filtered @else blocks don't pull in unused declarations.
 * @return new declarations found
 */
export function bindIdentsRecursive(
  scope: Scope,
  bindContext: BindContext,
  liveDecls: LiveDecls,
): DeclIdent[] {
  const { dontFollowDecls, foundScopes } = bindContext;
  if (foundScopes.has(scope)) return [];
  foundScopes.add(scope);

  const result = processScope(scope, bindContext, liveDecls);
  const { newGlobals, newFromChildren } = result;
  const newFromRefs = dontFollowDecls
    ? []
    : handleDecls(newGlobals, bindContext);
  return [newGlobals, newFromChildren, newFromRefs].flat();
}

/** Process all identifiers and subscopes in this scope. */
function processScope(
  scope: Scope,
  bindContext: BindContext,
  liveDecls: LiveDecls,
): { newGlobals: DeclIdent[]; newFromChildren: DeclIdent[] } {
  const newGlobals: DeclIdent[] = [];
  const newFromChildren: DeclIdent[] = [];

  for (const child of validItems(scope, bindContext.conditions)) {
    if (child.kind === "decl") {
      liveDecls.decls.set(child.originalName, child);
    } else if (child.kind === "ref") {
      const newDecl = handleRef(child, liveDecls, bindContext);
      if (newDecl) newGlobals.push(newDecl);
    } else {
      const newLive =
        child.kind === "scope" ? makeLiveDecls(liveDecls) : liveDecls;
      newFromChildren.push(...bindIdentsRecursive(child, bindContext, newLive));
    }
  }
  return { newGlobals, newFromChildren };
}

/** Process dependent scope for a single declaration. */
function processDependentScope(decl: DeclIdent, ctx: BindContext): DeclIdent[] {
  const { dependentScope } = decl;
  if (!dependentScope) return [];
  const rootDecls = rootLiveDecls(decl, ctx.conditions);
  if (!rootDecls) return [];
  return bindIdentsRecursive(dependentScope, ctx, makeLiveDecls(rootDecls));
}

/**
 * Trace references to their declarations.
 * Mutates to mangle declarations and mark std references.
 * @return found declaration, or undefined if already processed
 */
function handleRef(
  ident: RefIdent,
  liveDecls: LiveDecls,
  bindContext: BindContext,
): DeclIdent | undefined {
  if (ident.refersTo || ident.std) return;

  // Skip binding for condition refs - they resolve via Conditions map (for now)
  if (ident.conditionRef) return;

  const foundDecl =
    findDeclInModule(ident, liveDecls) ??
    findQualifiedImport(ident, bindContext);

  if (foundDecl) {
    ident.refersTo = foundDecl.decl;
    return handleNewDecl(ident, foundDecl, bindContext);
  }

  if (stdWgsl(ident.originalName)) {
    ident.std = true;
    return;
  }

  if (!bindContext.unbound)
    failIdent(ident, `unresolved identifier '${ident.originalName}'`);
}

function handleDecls(
  newGlobals: DeclIdent[],
  bindContext: BindContext,
): DeclIdent[] {
  return newGlobals.flatMap(decl => processDependentScope(decl, bindContext));
}

/** If found declaration is new, mangle its name. Return if it's a global declaration. */
function handleNewDecl(
  refIdent: RefIdent,
  foundDecl: FoundDecl,
  ctx: BindContext,
): DeclIdent | undefined {
  const { decl, moduleAst } = foundDecl;
  const { knownDecls, globalNames, mangler, globalStatements } = ctx;
  if (knownDecls.has(decl)) return;

  knownDecls.add(decl);
  const name = refIdent.originalName;
  setMangledName(name, decl, globalNames, decl.srcModule, mangler);
  if (!isGlobal(decl)) return;

  for (const elem of moduleAst.moduleAsserts ?? []) {
    globalStatements.set(elem, { srcModule: decl.srcModule, elem });
  }
  return decl;
}

/** Search current scope and parent scopes for a matching declaration. */
function findDeclInModule(
  ident: RefIdent,
  liveDecls: LiveDecls,
): FoundDecl | undefined {
  const found = liveDecls.decls.get(ident.originalName);
  if (found) return { decl: found, moduleAst: ident.ast };
  if (liveDecls.parent) return findDeclInModule(ident, liveDecls.parent);
}

/** Match a ref ident to a declaration in another module via import or qualified ident. */
function findQualifiedImport(
  refIdent: RefIdent,
  ctx: BindContext,
): FoundDecl | undefined {
  const { conditions, unbound } = ctx;
  const flatImps = flatImports(refIdent.ast, conditions);
  const identParts = refIdent.originalName.split("::");
  const pathParts =
    matchingImport(identParts, flatImps) ?? qualifiedIdent(identParts);

  if (!pathParts) {
    if (unbound && !stdWgsl(refIdent.originalName)) unbound.push(identParts);
    return undefined;
  }

  const result = findExport(pathParts, refIdent.ast.srcModule, ctx);
  if (!result) {
    if (unbound) unbound.push(pathParts);
    else failIdent(refIdent, `module not found for '${pathParts.join("::")}'`);
  }
  return result;
}

/** Find an import statement that matches a provided identifier. */
function matchingImport(
  identParts: string[],
  imports: FlatImport[],
): string[] | undefined {
  const flat = imports.find(f => f.importPath.at(-1) === identParts[0]);
  if (flat) return [...flat.modulePath, ...identParts.slice(1)];
}

/** Discovered declaration found during binding. */
interface FoundDecl {
  decl: DeclIdent;
  /** module containing the decl */
  moduleAst: WeslAST;
}

/** @return an exported root declIdent for the provided path. */
function findExport(
  pathParts: string[],
  srcModule: SrcModule,
  ctx: BindContext,
): FoundDecl | undefined {
  const { resolver, conditions, virtuals } = ctx;
  const srcParts = srcModule.modulePath.split("::");
  const fqParts = resolveSuper(pathParts, srcParts);
  const modulePath = fqParts.slice(0, -1).join("::");

  const moduleAst =
    resolver.resolveModule(modulePath) ??
    virtualModule(pathParts[0], conditions, virtuals);
  if (!moduleAst) return undefined;

  const decl = publicDecl(moduleAst.rootScope, last(pathParts)!, conditions);
  if (decl) return { decl, moduleAst };
}

/** @return AST for a virtual module. */
function virtualModule(
  moduleName: string,
  conditions: Conditions = {},
  virtuals?: VirtualLibrarySet,
): WeslAST | undefined {
  const found = virtuals?.[moduleName];
  if (!found) return undefined;
  if (found.ast) return found.ast;

  const src = found.fn(conditions);
  const modulePath = moduleName;
  const debugFilePath = moduleName;
  found.ast = parseSrcModule({ modulePath, debugFilePath, src });
  return found.ast;
}

/** Get cached valid root declarations, computing on first access. */
function getValidRootDecls(
  rootScope: Scope,
  conditions: Conditions,
): DeclIdent[] {
  const lexScope = rootScope as LexicalScope;
  if (!lexScope._validRootDecls) {
    lexScope._validRootDecls = findValidRootDecls(rootScope, conditions);
  }
  return lexScope._validRootDecls;
}

/** Given a global declIdent, return the liveDecls for its root scope. */
function rootLiveDecls(
  decl: DeclIdent,
  conditions: Conditions,
): LiveDecls | undefined {
  assertThatDebug(decl.isGlobal, identToString(decl));

  let scope = decl.containingScope;
  while (scope.parent) {
    scope = scope.parent;
  }
  assertThatDebug(scope.kind === "scope");

  const root = scope as LexicalScope;
  if (!root._scopeDecls) {
    const rootDecls = findValidRootDecls(scope, conditions);
    root._scopeDecls = {
      decls: new Map(rootDecls.map(d => [d.originalName, d])),
    };
  }
  return root._scopeDecls;
}

/** Set a globally unique mangled name for this declaration. */
function setMangledName(
  proposedName: string,
  decl: DeclIdent,
  globalNames: Set<string>,
  srcModule: SrcModule,
  mangler: ManglerFn,
): void {
  if (decl.mangledName) return;

  const sep = proposedName.lastIndexOf("::");
  const name = sep === -1 ? proposedName : proposedName.slice(sep + 2);
  const mangledName = isGlobal(decl)
    ? mangler(decl, srcModule, name, globalNames)
    : decl.originalName;
  decl.mangledName = mangledName;
  globalNames.add(mangledName);
}

/** @return true if ident is a standard WGSL type, fn, or enumerant. */
function stdWgsl(name: string): boolean {
  return stdType(name) || stdFn(name) || stdEnumerant(name); // TODO add tests for enumerants case (e.g. var x = read;)
}

function qualifiedIdent(identParts: string[]): string[] | undefined {
  if (identParts.length > 1) return identParts;
}

/** Collect all declarations in a scope (used when scope is already validated). */
function collectDecls(scope: Scope, found: DeclIdent[]): void {
  for (const item of scope.contents) {
    if (item.kind === "decl") found.push(item);
    else if (item.kind === "partial") collectDecls(item, found);
  }
}
