import type { AbstractElem } from "./AbstractElems.ts";
import { assertThatDebug } from "./Assertions.ts";
import { failIdent } from "./ClickableError.ts";
import { findConditional, validateConditional } from "./Conditions.ts";
import { identToString } from "./debug/ScopeToString.ts";
import type { FlatImport } from "./FlattenTreeImport.ts";
import type { LinkRegistryParams, VirtualLibraryFn } from "./Linker.ts";
import { type LiveDecls, makeLiveDecls } from "./LiveDeclarations.ts";
import { type ManglerFn, minimalMangle } from "./Mangler.ts";
import type { ModuleResolver } from "./ModuleResolver.ts";
import { flatImports, parseSrcModule, type WeslAST } from "./ParseWESL.ts";
import type {
  Conditions,
  DeclIdent,
  LexicalScope,
  RefIdent,
  Scope,
  SrcModule,
} from "./Scope.ts";
import { stdEnumerant, stdFn, stdType } from "./StandardTypes.ts";
import { last } from "./Util.ts";

/**
  BindIdents pass

  Goals:
  - link references identifiers to their declaration identifiers.
  - produce a list of declarations that are used (and need to be emitted in the link)
  - create mangled names for global declarations (to avoid name conflicts)

  BindIdents proceeds as a recursive tree walk of the scope tree, starting from the root module (e.g. main.wesl).
  It traverses the scope tree depth first (and not the syntax tree).
  - For each ref ident, search prior declarations in the current scope, then
    up the scope tree to find a matching declaration
  - If no local match is found, check for partial matches with import statements
    - combine the ident with import statement to match a decl in an exporting module
  - As global declaration identifies are found, also:
     - mutate their mangled name to be globally unique.
     - collect the declarations (they will be emitted)

  When iterating through the idents inside a scope, we maintain a parallel data structure of
  'liveDecls', the declarations that are visible in the current scope at the currently
  processed ident, along with a link to parent liveDecls for their current decl visibility.

  @if/@else Handling:
  The binding phase respects conditional compilation by tracking @else validity state as it
  processes sibling scopes. This prevents references from within filtered @else blocks from
  pulling in declarations that won't be emitted. The algorithm mirrors the emission phase's
  filterValidElements approach but operates on scopes rather than elements.
*/

/** results returned from binding pass */
export interface BindResults {
  /** root level names (including names mangled due to conflict with earlier names) */
  globalNames: Set<string>;

  /** global declarations that were referenced (these will need to be emitted in the link) */
  decls: DeclIdent[];

  /** additional global statements to include in linked results
   * (e.g. for adding module level const_assert statements) */
  newStatements: EmittableElem[];

  /** if accumulateUnbound is true, collection of unbound module paths */
  unbound?: string[][];
}

/** an element that can be directly emitted into the linked result */
export interface EmittableElem {
  srcModule: SrcModule;
  elem: AbstractElem;
}

/** virtual package, generated by code generation function. */
export interface VirtualLibrary {
  // LATER rename to VirtualPackage?
  /** function to generate the module */
  fn: VirtualLibraryFn;

  /** parsed AST for the module (constructed lazily) */
  ast?: WeslAST;
}

/** key is virtual module name */
export type VirtualLibrarySet = Record<string, VirtualLibrary>;

export interface BindIdentsParams
  extends Pick<LinkRegistryParams, "resolver" | "conditions" | "mangler"> {
  rootAst: WeslAST;
  virtuals?: VirtualLibrarySet;

  /** if false, throw on unbound identifiers. If true, accumulate unbound identifiers into
   * a BindResults.unbound.  */
  accumulateUnbound?: true;
}

/**
 * Bind active reference idents to declaration Idents by mutating the refersTo: field
 * Also in this pass, set the mangledName: field for all active global declaration idents.
 *
 * @param parsed
 * @param conditions  only bind to/from idents that are valid with the current condition set
 * @return any new declaration elements found (they will need to be emitted)
 */
export function bindIdents(params: BindIdentsParams): BindResults {
  const { rootAst, resolver, virtuals, accumulateUnbound } = params;
  const { conditions = {}, mangler = minimalMangle } = params;

  const validRootDecls = findValidRootDecls(rootAst.rootScope, conditions);
  const { globalNames, knownDecls } = initializeRootDecls(validRootDecls);

  const bindContext = {
    resolver,
    conditions,
    knownDecls,
    virtuals,
    mangler,
    foundScopes: new Set<Scope>(),
    globalNames,
    globalStatements: new Map<AbstractElem, EmittableElem>(),
    unbound: accumulateUnbound ? [] : undefined,
  };

  const declEntries = validRootDecls.map(d => [d.originalName, d] as const);
  const liveDecls: LiveDecls = { decls: new Map(declEntries), parent: null };

  const decls = bindIdentsRecursive(
    rootAst.rootScope,
    bindContext,
    liveDecls,
    true,
  );
  const newStatements = [...bindContext.globalStatements.values()];
  return { decls, globalNames, newStatements, unbound: bindContext.unbound };
}

/** Initialize root declarations with mangled names and add to tracking sets */
function initializeRootDecls(validRootDecls: DeclIdent[]): {
  globalNames: Set<string>;
  knownDecls: Set<DeclIdent>;
} {
  const globalNames = new Set<string>();
  const knownDecls = new Set<DeclIdent>();
  validRootDecls.forEach(decl => {
    decl.mangledName = decl.originalName;
    globalNames.add(decl.originalName);
    knownDecls.add(decl);
  });
  return { globalNames, knownDecls };
}

/**
 * Find all conditionally valid declarations at the root level.
 * Declarations are either directly in the root scope or in conditionally valid partial scopes.
 *
 * This function tracks @else state to ensure that declarations in @else blocks are only
 * included when the corresponding @if block is invalid. This is essential for preventing
 * unused declarations from being included in the output.
 *
 * Results are cached on the root scope's _validRootDecls field.
 * Used both for binding and for publicDecl() lookups.
 *
 * @param rootScope The root scope to search
 * @param conditions Current conditional compilation settings
 * @return Array of valid declaration identifiers
 */
export function findValidRootDecls(
  rootScope: Scope,
  conditions: Conditions,
): DeclIdent[] {
  const found: DeclIdent[] = [];
  let elseValid = false;

  for (const item of rootScope.contents) {
    if (item.kind === "decl") {
      assertThatDebug(item.declElem);
      const attr = findConditional(item.declElem.attributes);
      const validation = validateConditional(attr, elseValid, conditions);
      elseValid = validation.nextElseState;
      if (validation.valid) found.push(item);
    } else if (item.kind === "partial") {
      const validation = validateConditional(
        item.condAttribute,
        elseValid,
        conditions,
      );
      elseValid = validation.nextElseState;
      if (validation.valid) collectDecls(item, found);
    }
  }

  return found;
}

/** Find a public declaration with the given original name */
export function publicDecl(
  scope: Scope,
  name: string,
  conditions: Conditions,
): DeclIdent | undefined {
  const validDecls = getValidRootDecls(scope, conditions);
  return validDecls.find(d => d.originalName === name);
}

/** @return true if this decl is at the root scope level of a module */
export function isGlobal(declIdent: DeclIdent): boolean {
  const { declElem } = declIdent;
  if (!declElem) return false;

  return ["alias", "const", "override", "fn", "struct", "gvar"].includes(
    declElem.kind,
  );
}

/** state used during the recursive scope tree walk to bind references to declarations */
interface BindContext {
  resolver: ModuleResolver;
  conditions: Record<string, any>;

  /** decl idents discovered so far (to avoid re-traversing) */
  knownDecls: Set<DeclIdent>;

  /** save work by not processing scopes multiple times */
  foundScopes: Set<Scope>;

  /** root level names used so far (enables manglers/plugins to pick unique names) */
  globalNames: Set<string>;

  /** additional global statements to emit (e.g. module level const_assert, indexed by elem for uniqueness) */
  globalStatements: Map<AbstractElem, EmittableElem>;

  /** construct unique identifer names for global declarations */
  mangler: ManglerFn;

  virtuals?: VirtualLibrarySet;

  /** list of unbound identifiers if accumulateUnbound is true */
  unbound?: string[][];

  /** don't follow references from declarations (used for library dependency detection) */
  dontFollowDecls?: boolean;
}

/**
 * Recursively bind references to declarations in this scope and
 * any child scopes referenced by these declarations.
 * Uses a hash set of found declarations to avoid duplication.
 *
 * IMPORTANT: This function tracks @else state while traversing sibling scopes.
 * When an @if scope is processed, its validity determines whether the following
 * @else scope should be considered valid. This ensures that references from
 * filtered @else blocks don't pull in unused declarations.
 *
 * @return any new declarations found
 * @param liveDecls current set of live declaration in this scope
 *  (empty when traversing to a new scope, possibly non-empty for a partial scope)
 * @param isRoot liveDecls refers to a prepopulated root scope
 *  (root scope declarations may appear in any order)
 */
export function bindIdentsRecursive(
  scope: Scope,
  bindContext: BindContext,
  liveDecls: LiveDecls,
  isRoot = false,
): DeclIdent[] {
  const { dontFollowDecls, foundScopes } = bindContext;
  if (foundScopes.has(scope)) return [];
  foundScopes.add(scope);

  const { newGlobals, newFromChildren } = processScope(
    scope,
    bindContext,
    liveDecls,
    isRoot,
  );

  const newFromRefs = dontFollowDecls
    ? []
    : handleDecls(newGlobals, bindContext);

  return [newGlobals, newFromChildren, newFromRefs].flat();
}

/** Process all identifiers and subscopes in this scope */
function processScope(
  scope: Scope,
  bindContext: BindContext,
  liveDecls: LiveDecls,
  isRoot: boolean,
): { newGlobals: DeclIdent[]; newFromChildren: DeclIdent[] } {
  const newGlobals: DeclIdent[] = [];
  const newFromChildren: DeclIdent[] = [];
  let elseValid = false;

  scope.contents.forEach(child => {
    if (child.kind === "decl") {
      if (!isRoot) liveDecls.decls.set(child.originalName, child);
    } else if (child.kind === "ref") {
      const newDecl = handleRef(child, liveDecls, bindContext);
      if (newDecl) newGlobals.push(newDecl);
    } else {
      const fromScope = handleScope(child, liveDecls, bindContext, elseValid);
      if (fromScope) {
        newFromChildren.push(...fromScope.decls);
        elseValid = fromScope.nextElseState;
      }
    }
  });

  return { newGlobals, newFromChildren };
}

/**
 * Trace references to their declarations.
 * Mutates to mangle declarations and mark std references.
 *
 * @return the found declaration, or undefined if this ref has already been processed
 */
function handleRef(
  ident: RefIdent,
  liveDecls: LiveDecls,
  bindContext: BindContext,
): DeclIdent | undefined {
  const { resolver, conditions, unbound, virtuals } = bindContext;
  if (ident.refersTo || ident.std) return;

  const foundDecl =
    findDeclInModule(ident, liveDecls) ??
    findQualifiedImport(ident, resolver, conditions, virtuals, unbound);

  if (foundDecl) {
    ident.refersTo = foundDecl.decl;
    return handleNewDecl(ident, foundDecl, bindContext);
  } else if (stdWgsl(ident.originalName)) {
    ident.std = true;
  } else if (!unbound) {
    failIdent(ident, `unresolved identifier '${ident.originalName}'`);
  }
}

/**
 * Process a child scope, checking its conditional validity,
 * and tracking @else validity for siblings.
 * Updates liveDecls tree and recurses to process the elements in valid scopes.
 */
function handleScope(
  childScope: Scope,
  liveDecls: LiveDecls,
  bindContext: BindContext,
  elseValid: boolean,
): { decls: DeclIdent[]; nextElseState: boolean } | undefined {
  const { valid, nextElseState } = validateConditional(
    childScope.condAttribute,
    elseValid,
    bindContext.conditions,
  );
  if (!valid) return { decls: [], nextElseState };

  const newLiveDecls =
    childScope.kind === "scope" ? makeLiveDecls(liveDecls) : liveDecls;
  const decls = bindIdentsRecursive(childScope, bindContext, newLiveDecls);
  return { decls, nextElseState };
}

function handleDecls(
  newGlobals: DeclIdent[],
  bindContext: BindContext,
): DeclIdent[] {
  const { conditions } = bindContext;
  return newGlobals.flatMap(decl => {
    const foundScope = decl.dependentScope;
    if (!foundScope) return [];
    const rootDecls = rootLiveDecls(decl, conditions);
    if (!rootDecls) return [];
    const rootLive = makeLiveDecls(rootDecls);
    return bindIdentsRecursive(foundScope, bindContext, rootLive);
  });
}

/**
 * If the found declaration is new, mangle its name and update the
 * knownDecls and globalNames sets. Return it if it's a global declaration.
 */
function handleNewDecl(
  refIdent: RefIdent,
  foundDecl: FoundDecl,
  bindContext: BindContext,
): DeclIdent | undefined {
  const { decl, moduleAst } = foundDecl;
  const { knownDecls, globalNames, mangler, globalStatements } = bindContext;
  if (knownDecls.has(decl)) return;

  knownDecls.add(decl);
  setMangledName(
    refIdent.originalName,
    decl,
    globalNames,
    decl.srcModule,
    mangler,
  );

  if (isGlobal(decl)) {
    moduleAst.moduleAsserts?.forEach(elem => {
      globalStatements.set(elem, { srcModule: decl.srcModule, elem });
    });
    return decl;
  }
}

/** Search earlier in the scope and parent scopes for a matching declaration */
function findDeclInModule(
  ident: RefIdent,
  liveDecls: LiveDecls,
): FoundDecl | undefined {
  const found = liveDecls.decls.get(ident.originalName);
  if (found) return { decl: found, moduleAst: ident.ast };
  if (liveDecls.parent) return findDeclInModule(ident, liveDecls.parent);
}

/**
 * Match a reference identifier to a declaration in another module via an import statement
 * or via an inline qualified ident e.g. foo::bar().
 */
function findQualifiedImport(
  refIdent: RefIdent,
  resolver: ModuleResolver,
  conditions: Conditions,
  virtuals: VirtualLibrarySet | undefined,
  unbound: string[][] | undefined,
): FoundDecl | undefined {
  const flatImps = flatImports(refIdent.ast, conditions);
  const identParts = refIdent.originalName.split("::");
  const modulePathParts =
    matchingImport(identParts, flatImps) ?? qualifiedIdent(identParts);

  if (!modulePathParts) {
    if (unbound) unbound.push(identParts);
    return undefined;
  }

  const result = findExport(
    modulePathParts,
    refIdent.ast.srcModule,
    resolver,
    conditions,
    virtuals,
  );
  if (!result) {
    if (unbound) {
      unbound.push(modulePathParts);
    } else {
      failIdent(
        refIdent,
        `module not found for '${modulePathParts.join("::")}'`,
      );
    }
  }
  return result;
}

/** Find an import statement that matches a provided identifier */
function matchingImport(
  identParts: string[],
  flatImports: FlatImport[],
): string[] | undefined {
  for (const flat of flatImports) {
    if (flat.importPath.at(-1) === identParts.at(0)) {
      return [...flat.modulePath, ...identParts.slice(1)];
    }
  }
}

/** discovered declaration found during binding */
interface FoundDecl {
  decl: DeclIdent;
  /** module containing the decl */
  moduleAst: WeslAST;
}

/** @return an exported root declIdent for the provided path */
function findExport(
  modulePathParts: string[],
  srcModule: SrcModule,
  resolver: ModuleResolver,
  conditions: Conditions = {},
  virtuals?: VirtualLibrarySet,
): FoundDecl | undefined {
  const fqPathParts = absoluteModulePath(modulePathParts, srcModule);
  const modulePath = fqPathParts.slice(0, -1).join("::");
  const moduleAst =
    resolver.resolveModule(modulePath) ??
    virtualModule(modulePathParts[0], conditions, virtuals);
  if (!moduleAst) return undefined;

  const name = last(modulePathParts)!;
  const decl = publicDecl(moduleAst.rootScope, name, conditions);
  if (decl) return { decl, moduleAst };
}

/** @return AST for a virtual module */
function virtualModule(
  moduleName: string,
  conditions: Conditions = {},
  virtuals?: VirtualLibrarySet,
): WeslAST | undefined {
  if (!virtuals) return undefined;
  const found = virtuals[moduleName];
  if (!found) return undefined;

  if (found.ast) return found.ast;
  const src = found.fn(conditions);
  const srcModule: SrcModule = {
    modulePath: moduleName,
    debugFilePath: moduleName,
    src,
  };
  found.ast = parseSrcModule(srcModule);
  return found.ast;
}

/** Get cached valid root declarations, computing on first access */
function getValidRootDecls(
  rootScope: Scope,
  conditions: Conditions,
): DeclIdent[] {
  const lexScope = rootScope as LexicalScope;
  if (lexScope._validRootDecls) return lexScope._validRootDecls;

  const valid = findValidRootDecls(rootScope, conditions);
  lexScope._validRootDecls = valid;
  return valid;
}

/** Given a global declIdent, return the liveDecls for its root scope */
function rootLiveDecls(
  decl: DeclIdent,
  conditions: Conditions,
): LiveDecls | undefined {
  assertThatDebug(decl.isGlobal, identToString(decl));
  let rootScope = decl.containingScope;
  while (rootScope.parent) {
    rootScope = rootScope.parent;
  }
  assertThatDebug(rootScope.kind === "scope");
  const root = rootScope as LexicalScope;
  if (root._scopeDecls) return root._scopeDecls;

  const rootDecls = findValidRootDecls(rootScope, conditions);
  const entries = rootDecls.map(d => [d.originalName, d] as const);
  const liveDecls = { decls: new Map(entries) };
  root._scopeDecls = liveDecls;
  return liveDecls;
}

/**
 * Set a globally unique mangled name for this declaration.
 * Uses the mangler function to avoid name collisions.
 */
function setMangledName(
  proposedName: string,
  decl: DeclIdent,
  globalNames: Set<string>,
  srcModule: SrcModule,
  mangler: ManglerFn,
): void {
  if (decl.mangledName) return;

  let mangledName: string;
  if (isGlobal(decl)) {
    const sep = proposedName.lastIndexOf("::");
    const name = sep === -1 ? proposedName : proposedName.slice(sep + 2);
    mangledName = mangler(decl, srcModule, name, globalNames);
  } else {
    mangledName = decl.originalName;
  }
  decl.mangledName = mangledName;
  globalNames.add(mangledName);
}

/** @return true if ident is a standard wgsl type, fn, or enumerant */
function stdWgsl(name: string): boolean {
  return stdType(name) || stdFn(name) || stdEnumerant(name); // TODO add tests for enumerants case (e.g. var x = read;)
}

function qualifiedIdent(identParts: string[]): string[] | undefined {
  if (identParts.length > 1) return identParts;
}

/** Convert a module path with super:: elements to one with no super:: elements */
function absoluteModulePath(
  modulePathParts: string[],
  srcModule: SrcModule,
): string[] {
  const lastSuper = modulePathParts.lastIndexOf("super");
  if (lastSuper === -1) return modulePathParts;

  const srcModuleParts = srcModule.modulePath.split("::");
  const base = srcModuleParts.slice(0, -(lastSuper + 1));
  const noSupers = modulePathParts.slice(lastSuper + 1);
  return [...base, ...noSupers];
}

/** Collect all declarations in a scope (used when scope is already validated) */
function collectDecls(scope: Scope, found: DeclIdent[]): void {
  for (const item of scope.contents) {
    if (item.kind === "decl") {
      found.push(item);
    } else if (item.kind === "partial") {
      collectDecls(item, found);
    }
  }
}
