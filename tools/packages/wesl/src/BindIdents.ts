import type { AbstractElem, ElemWithAttributes } from "./AbstractElems.ts";
import { assertThatDebug } from "./Assertions.ts";
import { failIdent } from "./ClickableError.ts";
import { validateAttributes, validateConditional } from "./Conditions.ts";
import { identToString } from "./debug/ScopeToString.ts";
import type { FlatImport } from "./FlattenTreeImport.ts";
import type { LinkRegistryParams, VirtualLibraryFn } from "./Linker.ts";
import { type LiveDecls, makeLiveDecls } from "./LiveDeclarations.ts";
import { type ManglerFn, minimalMangle } from "./Mangler.ts";
import type { ParsedRegistry } from "./ParsedRegistry.ts";
import { flatImports, parseSrcModule, type WeslAST } from "./ParseWESL.ts";
import {
  type Conditions,
  type DeclIdent,
  type LexicalScope,
  publicDecl,
  type RefIdent,
  type Scope,
  type SrcModule,
} from "./Scope.ts";
import { stdEnumerant, stdFn, stdType } from "./StandardTypes.ts";
import { last } from "./Util.ts";

/**
  BindIdents pass

  Goals:
  - link references identifiers to their declaration identifiers.
  - produce a list of declarations that are used (and need to be emitted in the link)
  - create mangled names for global declarations (to avoid name conflicts)

  BindIdents proceeds as a recursive tree walk of the scope tree, starting from the root module (e.g. main.wesl).
  It traverses the scope tree depth first (and not the syntax tree).
  - For each ref ident, search prior declarations in the current scope, then
    up the scope tree to find a matching declaration
  - If no local match is found, check for partial matches with import statements
    - combine the ident with import statement to match a decl in an exporting module
  - As global declaration identifies are found, also:
     - mutate their mangled name to be globally unique.
     - collect the declarations (they will be emitted)

  When iterating through the idents inside a scope, we maintain a parallel data structure of
  'liveDecls', the declarations that are visible in the current scope at the currently
  processed ident, along with a link to parent liveDecls for their current decl visibility.

  @if/@else Handling:
  The binding phase respects conditional compilation by tracking @else validity state as it
  processes sibling scopes. This prevents references from within filtered @else blocks from
  pulling in declarations that won't be emitted. The algorithm mirrors the emission phase's
  filterValidElements approach but operates on scopes rather than elements.
*/

/** results returned from binding pass */
export interface BindResults {
  /** root level names (including names mangled due to conflict with earlier names) */
  globalNames: Set<string>;

  /** global declarations that were referenced (these will need to be emitted in the link) */
  decls: DeclIdent[];

  /** additional global statements to include in linked results
   * (e.g. for adding module level const_assert statements) */
  newStatements: EmittableElem[];

  /** if accumulateUnbound is true, collection of unbound module paths */
  unbound?: string[][];
}

/** an element that can be directly emitted into the linked result */
export interface EmittableElem {
  srcModule: SrcModule;
  elem: AbstractElem;
}

/** virtual package, generated by code generation function. */
export interface VirtualLibrary {
  // LATER rename to VirtualPackage?
  /** function to generate the module */
  fn: VirtualLibraryFn;

  /** parsed AST for the module (constructed lazily) */
  ast?: WeslAST;
}

/** key is virtual module name */
export type VirtualLibrarySet = Record<string, VirtualLibrary>;

export interface BindIdentsParams
  extends Pick<LinkRegistryParams, "registry" | "conditions" | "mangler"> {
  rootAst: WeslAST;
  virtuals?: VirtualLibrarySet;

  /** if false, throw on unbound identifiers. If true, accumulate unbound identifiers into
   * a BindResults.unbound.  */
  accumulateUnbound?: true;
}

/**
 * Bind active reference idents to declaration Idents by mutating the refersTo: field
 * Also in this pass, set the mangledName: field for all active global declaration idents.
 *
 * @param parsed
 * @param conditions  only bind to/from idents that are valid with the current condition set
 * @return any new declaration elements found (they will need to be emitted)
 */
export function bindIdents(params: BindIdentsParams): BindResults {
  const { rootAst, registry, virtuals, accumulateUnbound } = params;
  const { conditions = {}, mangler = minimalMangle } = params;
  const { rootScope } = rootAst;

  const globalNames = new Set<string>();
  const knownDecls = new Set<DeclIdent>();
  const validRootDecls = findValidRootDecls(rootScope, conditions);

  validRootDecls.forEach(decl => {
    decl.mangledName = decl.originalName;
    globalNames.add(decl.originalName);
    knownDecls.add(decl);
  });

  const unbound = accumulateUnbound ? [] : undefined;
  const globalStatements = new Map<AbstractElem, EmittableElem>();
  const bindContext = {
    registry,
    conditions,
    knownDecls,
    foundScopes: new Set<Scope>(),
    globalNames,
    globalStatements,
    virtuals,
    mangler,
    unbound,
  };

  // initialize liveDecls with all module level declarations
  // (note that in wgsl module level declarations may appear in any order, incl after their references.)
  const declEntries = validRootDecls.map(d => [d.originalName, d] as const);
  const liveDecls: LiveDecls = { decls: new Map(declEntries), parent: null };

  const decls = bindIdentsRecursive(rootScope, bindContext, liveDecls, true);
  const newStatements = [...globalStatements.values()];
  return { decls, globalNames, newStatements, unbound };
}

/** bind local references in library sources to reveal references to external packages */
export function findUnboundIdents(registry: ParsedRegistry): string[][] {
  const bindContext = {
    registry,
    conditions: {},
    knownDecls: new Set<DeclIdent>(),
    foundScopes: new Set<Scope>(),
    globalNames: new Set<string>(),
    globalStatements: new Map<AbstractElem, EmittableElem>(),
    mangler: minimalMangle,
    unbound: [],
    dontFollowDecls: true,
  };

  Object.entries(registry.modules).forEach(([_module, ast]) => {
    const rootDecls = findValidRootDecls(ast.rootScope, {});
    const declEntries = rootDecls.map(d => [d.originalName, d] as const);
    const liveDecls: LiveDecls = { decls: new Map(declEntries), parent: null };
    bindIdentsRecursive(ast.rootScope, bindContext, liveDecls, true);
  });

  return bindContext.unbound;
}

/**
 * Find all conditionally valid declarations at the root level.
 * Declarations are either directly in the root scope or in conditionally valid partial scopes.
 *
 * This function tracks @else state to ensure that declarations in @else blocks are only
 * included when the corresponding @if block is invalid. This is essential for preventing
 * unused declarations from being included in the output.
 *
 * @param rootScope The root scope to search
 * @param conditions Current conditional compilation settings
 * @return Array of valid declaration identifiers
 */
export function findValidRootDecls(
  rootScope: Scope,
  conditions: Conditions,
): DeclIdent[] {
  const found: DeclIdent[] = [];
  let elseValid = false;

  for (const item of rootScope.contents) {
    if (item.kind === "decl") {
      assertThatDebug(item.declElem);
      const { valid, nextElseState } = validateAttributes(
        (item.declElem as ElemWithAttributes).attributes,
        elseValid,
        conditions,
      );
      elseValid = nextElseState;
      if (valid) {
        found.push(item);
      }
    } else if (item.kind === "partial") {
      const { valid, nextElseState } = validateConditional(
        item.condAttribute,
        elseValid,
        conditions,
      );
      elseValid = nextElseState;
      if (valid) {
        collectAllDeclarationsInScope(item, found);
      }
    }
  }

  return found;
}

/** Collect all declarations in a scope (used when scope is already validated) */
function collectAllDeclarationsInScope(scope: Scope, found: DeclIdent[]): void {
  for (const item of scope.contents) {
    if (item.kind === "decl") {
      found.push(item);
    } else if (item.kind === "partial") {
      collectAllDeclarationsInScope(item, found);
    }
  }
}

/** state used during the recursive scope tree walk to bind references to declarations */
interface BindContext {
  registry: ParsedRegistry;

  /** live runtime conditions currently defined by the user */
  conditions: Record<string, any>;

  /** decl idents discovered so far (to avoid re-traversing) */
  knownDecls: Set<DeclIdent>;

  /** save work by not processing scopes multiple times */
  foundScopes: Set<Scope>;

  /** root level names used so far (so that manglers or ast rewriting plugins can pick unique names) */
  globalNames: Set<string>;

  /** additional global statements to include in linked results
   * (e.g. for adding module level const_assert statements)
   * (indexed by elem for uniqueness) */
  globalStatements: Map<AbstractElem, EmittableElem>;

  /** construct unique identifer names for global declarations */
  mangler: ManglerFn;

  /** virtual libraries provided by the user (e.g. for code generators or constants) */
  virtuals?: VirtualLibrarySet;

  /** list of unbound identifiers if accumulateUnbound is true */
  unbound?: string[][];

  /** don't recurse to follow references from declarations in other modules
   * (for libraries, where we're not tracing static usage from the root) */
  dontFollowDecls?: boolean;
}

/**
 * Recursively bind references to declarations in this scope and
 * any child scopes referenced by these declarations.
 * Uses a hash set of found declarations to avoid duplication.
 *
 * IMPORTANT: This function tracks @else state while traversing sibling scopes.
 * When an @if scope is processed, its validity determines whether the following
 * @else scope should be considered valid. This ensures that references from
 * filtered @else blocks don't pull in unused declarations.
 *
 * @return any new declarations found
 * @param liveDecls current set of live declaration in this scope
 *  (empty when traversing to a new scope, possibly non-empty for a partial scope)
 * @param isRoot liveDecls refers to a prepopulated root scope
 *  (root scope declarations may appear in any order)
 */
function bindIdentsRecursive(
  scope: Scope,
  bindContext: BindContext,
  liveDecls: LiveDecls,
  isRoot = false,
): DeclIdent[] {
  // early exit if we've processed this scope before
  const { dontFollowDecls, foundScopes } = bindContext;
  if (foundScopes.has(scope)) return [];
  foundScopes.add(scope);

  const newGlobals: DeclIdent[] = []; // new decl idents to process for binding (and return for emitting)

  // active declarations in this scope
  const newFromChildren: DeclIdent[] = [];

  // Track @else validity state across sibling scopes.
  let elseValid = false;

  // process all identifiers and subscopes in this scope
  scope.contents.forEach(child => {
    const { kind } = child;
    if (kind === "decl") {
      if (!isRoot) liveDecls.decls.set(child.originalName, child);
    } else if (kind === "ref") {
      const newDecl = handleRef(child, liveDecls, bindContext);
      if (newDecl) newGlobals.push(newDecl);
    } else {
      const fromScope = handleScope(child, liveDecls, bindContext, elseValid);
      if (fromScope) {
        newFromChildren.push(...fromScope.decls);
        elseValid = fromScope.nextElseState;
      }
    }
  });

  // follow references from referenced declarations
  const newFromRefs = dontFollowDecls
    ? []
    : handleDecls(newGlobals, bindContext);

  return [newGlobals, newFromChildren, newFromRefs].flat();
}

function handleDecls(
  newGlobals: DeclIdent[],
  bindContext: BindContext,
): DeclIdent[] {
  const { conditions } = bindContext;
  return newGlobals.flatMap(decl => {
    const foundScope = decl.dependentScope;
    if (!foundScope) return [];
    const rootDecls = globalDeclToRootLiveDecls(decl, conditions);
    if (!rootDecls) return [];
    const rootLive = makeLiveDecls(rootDecls);
    return bindIdentsRecursive(foundScope, bindContext, rootLive);
  });
}

/**
 * Trace references to their declarations
 * mutates to:
 *  mangle declarations
 *  mark references as 'std' if they match a wgsl std function or type
 *
 * @return the found declaration, or undefined if this ref has already been processed
 */
function handleRef(
  ident: RefIdent,
  liveDecls: LiveDecls,
  bindContext: BindContext,
): DeclIdent | undefined {
  const { registry, conditions, unbound, virtuals } = bindContext;
  if (ident.refersTo || ident.std) return;

  const foundDecl =
    findDeclInModule(ident, liveDecls) ??
    findQualifiedImport(ident, registry, conditions, virtuals, unbound);

  if (foundDecl) {
    ident.refersTo = foundDecl.decl;
    return handleNewDecl(ident, foundDecl, bindContext);
  } else if (stdWgsl(ident.originalName)) {
    ident.std = true;
  } else if (!unbound) {
    failIdent(ident, `unresolved identifier '${ident.originalName}'`);
  }
}

/**
 * Process a child scope, checking its conditional validity,
 * and tracking @else validity for siblings.
 * Updates liveDecls tree and recurses to process the elements in valid scopes.
 */
function handleScope(
  childScope: Scope,
  liveDecls: LiveDecls,
  bindContext: BindContext,
  elseValid: boolean,
): { decls: DeclIdent[]; nextElseState: boolean } | undefined {
  const { valid, nextElseState } = validateConditional(
    childScope.condAttribute,
    elseValid,
    bindContext.conditions,
  );
  if (!valid) return { decls: [], nextElseState };

  const newLiveDecls =
    childScope.kind === "scope" ? makeLiveDecls(liveDecls) : liveDecls;
  const decls = bindIdentsRecursive(childScope, bindContext, newLiveDecls);
  return { decls, nextElseState };
}

/**
 * If the found declaration is new, mangle its name and update the
 * knownDecls and globalNames sets. Return it if it's a global declaration.
 */
function handleNewDecl(
  refIdent: RefIdent,
  foundDecl: FoundDecl,
  bindContext: BindContext,
): DeclIdent | undefined {
  const { decl, moduleAst } = foundDecl;
  const { knownDecls, globalNames, mangler, globalStatements } = bindContext;
  if (knownDecls.has(decl)) return;

  knownDecls.add(decl);
  setMangledName(
    refIdent.originalName,
    decl,
    globalNames,
    decl.srcModule,
    mangler,
  );

  if (isGlobal(decl)) {
    moduleAst.moduleAsserts?.forEach(elem => {
      globalStatements.set(elem, { srcModule: decl.srcModule, elem });
    });
    return decl;
  }
}

/** given a global declIdent, return the liveDecls for its root scope */
function globalDeclToRootLiveDecls(
  decl: DeclIdent,
  conditions: Conditions,
): LiveDecls | undefined {
  assertThatDebug(decl.isGlobal, identToString(decl));
  let rootScope = decl.containingScope;
  while (rootScope.parent) {
    rootScope = rootScope.parent;
  }
  assertThatDebug(rootScope.kind === "scope");
  const root = rootScope as LexicalScope;
  if (root._scopeDecls) return root._scopeDecls;

  const rootDecls = findValidRootDecls(rootScope, conditions);
  const entires = rootDecls.map(d => [d.originalName, d] as const);
  const decls = new Map(entires);
  const liveDecls = { decls };
  root._scopeDecls = liveDecls;
  return liveDecls;
}

/**
 * Mutate a DeclIdent to set a unique name for global linking
 * using a mangling function to choose a unique name.
 * Also update the set of globally unique names.
 */
function setMangledName(
  proposedName: string,
  decl: DeclIdent,
  globalNames: Set<string>,
  srcModule: SrcModule,
  mangler: ManglerFn,
): void {
  if (!decl.mangledName) {
    let mangledName: string;
    if (isGlobal(decl)) {
      const sep = proposedName.lastIndexOf("::");
      const name = sep === -1 ? proposedName : proposedName.slice(sep + 2);
      mangledName = mangler(decl, srcModule, name, globalNames);
    } else {
      mangledName = decl.originalName;
    }
    decl.mangledName = mangledName;
    globalNames.add(mangledName);
  }
}

/** @return true if ident is a standard wgsl type, fn, or enumerant */
function stdWgsl(name: string): boolean {
  return stdType(name) || stdFn(name) || stdEnumerant(name); // TODO add tests for enumerants case (e.g. var x = read;)
}

/** Using the LiveDecls, search earlier in the scope and in parent scopes to find a matching decl ident */
function findDeclInModule(
  ident: RefIdent,
  liveDecls: LiveDecls,
): FoundDecl | undefined {
  const found = liveDecls.decls.get(ident.originalName);
  if (found) return { decl: found, moduleAst: ident.ast };
  if (liveDecls.parent) return findDeclInModule(ident, liveDecls.parent);
}

/**
 * Match a reference identifier to a declaration in another module via an import statement
 * or via an inline qualified ident e.g. foo::bar().
 */
function findQualifiedImport(
  refIdent: RefIdent,
  parsed: ParsedRegistry,
  conditions: Conditions,
  virtuals: VirtualLibrarySet | undefined,
  unbound: string[][] | undefined,
): FoundDecl | undefined {
  const flatImps = flatImports(refIdent.ast, conditions);
  const identParts = refIdent.originalName.split("::");

  // find module path by combining identifer reference with import statement
  const modulePathParts =
    matchingImport(identParts, flatImps) ?? qualifiedIdent(identParts);

  if (modulePathParts) {
    const result = findExport(
      modulePathParts,
      refIdent.ast.srcModule,
      parsed,
      conditions,
      virtuals,
    );
    if (!result) {
      if (unbound) {
        unbound.push(modulePathParts);
      } else {
        failIdent(
          refIdent,
          `module not found for '${modulePathParts.join("::")}'`,
        );
      }
    }
    return result;
  } else if (unbound) {
    unbound.push(identParts);
  }
}

function qualifiedIdent(identParts: string[]): string[] | undefined {
  if (identParts.length > 1) return identParts;
}

/** Combine an import using the flattened import array, find an import that matches a provided ident */
function matchingImport(
  identParts: string[],
  flatImports: FlatImport[],
): string[] | undefined {
  for (const flat of flatImports) {
    if (flat.importPath.at(-1) === identParts.at(0)) {
      return [...flat.modulePath, ...identParts.slice(1)];
    }
  }
}

/** discovered declaration found during binding */
interface FoundDecl {
  decl: DeclIdent;
  /** module containing the decl */
  moduleAst: WeslAST;
}

/** @return an exported root declIdent for the provided path */
function findExport(
  modulePathParts: string[],
  srcModule: SrcModule,
  parsed: ParsedRegistry,
  conditions: Conditions = {},
  virtuals?: VirtualLibrarySet,
): FoundDecl | undefined {
  const fqPathParts = absoluteModulePath(modulePathParts, srcModule);
  const modulePath = fqPathParts.slice(0, -1).join("::");
  const moduleAst =
    parsed.modules[modulePath] ??
    virtualModule(modulePathParts[0], conditions, virtuals);
  if (!moduleAst) return undefined;

  const name = last(modulePathParts)!;
  const decl = publicDecl(moduleAst.rootScope, name, conditions);
  if (decl) return { decl, moduleAst };
}

/** Convert a module path with super:: elements to one with no super:: elements */
function absoluteModulePath(
  modulePathParts: string[],
  srcModule: SrcModule,
): string[] {
  const lastSuper = modulePathParts.lastIndexOf("super");
  if (lastSuper === -1) return modulePathParts;

  const srcModuleParts = srcModule.modulePath.split("::");
  const base = srcModuleParts.slice(0, -(lastSuper + 1));
  const noSupers = modulePathParts.slice(lastSuper + 1);
  return [...base, ...noSupers];
}

/** @return AST for a virtual module */
function virtualModule(
  moduleName: string,
  conditions: Conditions = {},
  virtuals?: VirtualLibrarySet,
): WeslAST | undefined {
  if (!virtuals) return undefined;
  const found = virtuals[moduleName];
  if (!found) return undefined;

  if (found.ast) return found.ast;
  const src = found.fn(conditions);
  const srcModule: SrcModule = {
    modulePath: moduleName,
    debugFilePath: moduleName,
    src,
  };
  found.ast = parseSrcModule(srcModule);
  return found.ast;
}

// LATER capture isGlobal in the ident during parsing
/** @return true if this decl is at the root scope level of a module */
export function isGlobal(declIdent: DeclIdent): boolean {
  const { declElem } = declIdent;
  if (!declElem) return false;

  return ["alias", "const", "override", "fn", "struct", "gvar"].includes(
    declElem.kind,
  );
}
